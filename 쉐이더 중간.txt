GLSL? 프로그래밍 가능한 그래픽스 파이프라인을 제어할 수 있는 상위 레벨 언어 
        버텍스 쉐이더, 지오메트리 쉐이더, 프레그먼트 쉐이더로 이루어짐 

고정 그래픽스 파이프라인
Vertex Transform -> primitive Assembly -> Rasterization and Interpolation ->Fragment Operation -> Frame Buffer 
각 단계는 미리 주어진 연산만 수행이 가능 

프로그램 가능한 파이프라인 
Vertex Shader -> Primitive Assembly -> Rasterization and Interpolation -> Fragment Shader -> Frame Buffer 

데이터준비 
glGenBuffers(1, &m_VBORect);
glBindBuffer(GL_ARRAY_BUFFER, m_VBORect);
glBufferData(GL_ARRAY_BUFFER, sizeof(rect), rect, GL_STATIC_DRAW);	

데이터사용 
glUseProgram(m_FillAllShader);

glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // 알파블렌딩 사용 

//유니폼 사용 
GLuint uTime = glGetUniformLocation(m_FillAllShader, "u_Time");
glUniform1f(uTime, g_Time);
g_Time += 0.0001f;

GLuint aPos = glGetAttribLocation(m_SimpleVelShader, "a_Position"); //로케이션을 사용하지 않는 방법 

glEnableVertexAttribArray(aPos);

glBindBuffer(GL_ARRAY_BUFFER, m_QuadRect);

glVertexAttribPointer(aPos, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 15, 0);

glDrawArrays(GL_TRIANGLES, 0, quad_vertex_count);

glDisableVertexAttribArray(aPos);


사각형 만듣기 
int verticesPerQuad = 6; //사각형당 필요한 버텍스 

int floatsPerVertex = 3 + 3 + 2; //버텍스 하나에 들어가는 자료의 갯수(위치, 속도, 시간 등) 

int countQuad = num; //사각형 갯수 

int vertex_size = countQuad * verticesPerQuad * floatsPerVertex;

glGenBuffers(1, &m_QuadRect);
glBindBuffer(GL_ARRAY_BUFFER, m_QuadRect);
glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertex_size, Quad_vertex, GL_STATIC_DRAW); 

glDrawArrays(GL_TRIANGLES, 0, quad_vertex_count); //여기에 버텍스 카운트(vertex_size)가 들어간다. 

*layout 사용 
glEnableVertexAttribArray(0); //cpp파일에서 0으로 지정해주면 
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);

layout(location = 0) in vec3 Position; //버텍스 쉐이더파일에서 연동 됨 

사인곡선으로 이동하는 파티클 
newPos.x += NewTime; 
newPos.y += sin(newTime * 2 * PI * 주기) * 진폭;

//중력 
newPos = newPos + a_Vel * newTime +  0.5 * c_Gravity * newTime * newTime;

//프래그먼트 쉐이더 원그리기 
float dis = sqrt(v_orixy.x * v_orixy.x + v_orixy.y * v_orixy.y);
if(dis < v_radius)
{
	newcolor = v_color; 
}
else
{
	newcolor = vec4(0,0,0,0);
}
Fragcolor = newcolor; 


레이더 적군 그리기 
float pointGrey = 0;

for (int i = 0; i < 2; i++)
{
	vec2 newPoint = c_Points[i];
	vec2 newVec = newPoint - newUV;
	float distance = sqrt(newVec.x * newVec.x + newVec.y * newVec.y);
	if(distance < 0.1)
	{
		pointGrey += 0.5 * pow(1-(distance/0.1),5);
	}

}

FragColor = vec4(pointGrey);

레이더 그리기 
float distance = length(newUV);
float newTime = fract(u_Time);
float ringWidth = 0.1;

if(distance < newTime + ringWidth && distance > newTime)
{
	float temp = (distance - newTime)/ringWidth;
	pointGrey = temp;
}


텍스처 적용하기 
m_ParticleTexture = CreatePngTexture("./Particles/p1.png"); //이니셜라이즈 

int uniformTex = glGetUniformLocation(m_TextureShader, "u_Texture");
glUniform1i(uniformTex, 0);
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, m_ParticleTexture); //드로우부분 

newColor = texture(u_Texture, v_UV); //프래그먼트에서 

사인곡선 그리기 
float length = 0.01f;
float UV_x = v_UV.x;
UV_x += u_Time;

if( v_UV.y - 0.5 < sin(UV_x * 3.14 * 2) / 2 + length)
{
	if( v_UV.y - 0.5 > sin(UV_x * 3.14 * 2) / 2 -length)
		newColor = vec4(1);
}
FragColor = newColor;






